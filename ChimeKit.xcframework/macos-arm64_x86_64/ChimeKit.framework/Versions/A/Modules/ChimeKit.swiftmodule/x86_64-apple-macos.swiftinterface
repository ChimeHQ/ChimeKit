// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.123.7 clang-1400.0.29.50)
// swift-module-flags: -target x86_64-apple-macos11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name ChimeKit
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AnyCodable
@_exported import ChimeKit
import Combine
import ConcurrencyPlus
import ExtensionKit
import Foundation
import JSONRPC
import LanguageClient
import LanguageServerProtocol
import ProcessEnv
import Swift
import SwiftUI
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import os.log
import os
extension ChimeKit.LineRelativeTextPosition {
  public var lspPosition: LanguageServerProtocol.Position {
    get
  }
  public init(_ lspPosition: LanguageServerProtocol.Position)
}
extension ChimeKit.CombinedTextPosition {
  public var lspPosition: LanguageServerProtocol.Position {
    get
  }
}
extension Swift.Range where Bound == ChimeKit.LineRelativeTextPosition {
  public init(_ lspRange: LanguageServerProtocol.LSPRange)
  public var lspRange: LanguageServerProtocol.LSPRange {
    get
  }
}
extension ChimeKit.CombinedTextRange {
  public var lspRange: LanguageServerProtocol.LSPRange {
    get
  }
}
extension LanguageServerProtocol.TextEdit {
  public var textRange: ChimeKit.TextRange {
    get
  }
}
extension LanguageServerProtocol.LSPRange {
  public var textRange: ChimeKit.TextRange {
    get
  }
}
extension LanguageServerProtocol.ThreeTypeOption where T == LanguageServerProtocol.TwoTypeOption<Swift.String, LanguageServerProtocol.LanguageStringPair>, U == [LanguageServerProtocol.TwoTypeOption<Swift.String, LanguageServerProtocol.LanguageStringPair>], V == LanguageServerProtocol.MarkupContent {
  public var value: Swift.String? {
    get
  }
}
extension LanguageServerProtocol.Hover {
  public var value: Swift.String? {
    get
  }
}
public enum ChimeExtensionPoint : Swift.String, Swift.CaseIterable, Swift.Hashable, Swift.Codable, Swift.Sendable {
  case nonui
  case sidebarUI
  case documentSyncedUI
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ChimeKit.ChimeExtensionPoint]
  public typealias RawValue = Swift.String
  public static var allCases: [ChimeKit.ChimeExtensionPoint] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public protocol ChimeBaseExtension : ChimeKit.ExtensionProtocol {
  var hostApp: ChimeKit.HostProtocol? { get set }
}
public struct ChimeExtensionConfiguration<Extension> : ExtensionFoundation.AppExtensionConfiguration where Extension : ChimeKit.ChimeBaseExtension {
  public init(_ appExtension: Extension)
  public func accept(connection: Foundation.NSXPCConnection) -> Swift.Bool
}
@available(macOS 13.0, *)
public protocol ChimeExtension : ChimeKit.ChimeBaseExtension, ExtensionFoundation.AppExtension {
}
@available(macOS 13.0, *)
extension ChimeKit.ChimeExtension {
  public var configuration: ChimeKit.ChimeExtensionConfiguration<Self> {
    get
  }
}
@available(macOS 13.0, *)
public protocol SidebarChimeUIExtension : ChimeKit.ChimeBaseExtension, ExtensionFoundation.AppExtension {
  associatedtype Body : SwiftUI.View
  var body: Self.Body { get }
}
@available(macOS 13.0, *)
extension ChimeKit.SidebarChimeUIExtension {
  public var configuration: ExtensionKit.AppExtensionSceneConfiguration {
    get
  }
}
@available(macOS 13.0, *)
public protocol DocumentSyncedChimeUIExtension : ChimeKit.ChimeBaseExtension, ExtensionFoundation.AppExtension {
  associatedtype Body : SwiftUI.View
  var body: Self.Body { get }
}
@available(macOS 13.0, *)
extension ChimeKit.DocumentSyncedChimeUIExtension {
  public var configuration: ExtensionKit.AppExtensionSceneConfiguration {
    get
  }
}
@objc(CodingCombinedTextContent) final public class CodingCombinedTextContent : ObjectiveC.NSObject {
  final public let value: ChimeKit.CombinedTextContent
  public init(_ value: ChimeKit.CombinedTextContent)
  @objc deinit
}
extension ChimeKit.CodingCombinedTextContent : Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  @objc final public func encode(with coder: Foundation.NSCoder)
  @objc convenience dynamic public init?(coder: Foundation.NSCoder)
}
public protocol HostProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  func textContent(for documentId: ChimeKit.DocumentIdentity) async throws -> (Swift.String, Swift.Int)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func textContent(for documentId: ChimeKit.DocumentIdentity, in range: ChimeKit.TextRange) async throws -> ChimeKit.CombinedTextContent
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func textBounds(for documentId: ChimeKit.DocumentIdentity, in ranges: [ChimeKit.TextRange], version: Swift.Int) async throws -> [Foundation.NSRect]
  #endif
  func publishDiagnostics(_ diagnostics: [ChimeKit.Diagnostic], for documentURL: Foundation.URL, version: Swift.Int?)
  func invalidateTokens(for documentId: ChimeKit.DocumentIdentity, in target: ChimeKit.TextTarget)
  func documentServiceConfigurationChanged(for documentId: ChimeKit.DocumentIdentity, to configuration: ChimeKit.ServiceConfiguration)
}
extension ChimeKit.HostProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  public func textContent(for documentId: ChimeKit.DocumentIdentity, in range: ChimeKit.CombinedTextRange) async throws -> ChimeKit.CombinedTextContent
  #endif
}
public enum LSPServiceError : Swift.Error {
  case unsupported
  case noProjectConnection(Foundation.URL)
  case noDocumentConnection(ChimeKit.DocumentContext)
  case documentURLInvalid(ChimeKit.DocumentContext)
}
#if compiler(>=5.3) && $Actors
public actor LSPService {
  #if compiler(>=5.3) && $AsyncAwait
  public typealias ExecutionParamsProvider = () async throws -> Foundation.Process.ExecutionParameters
  #endif
  public typealias DocumentFilter = (ChimeKit.DocumentContext) -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  public init(host: ChimeKit.HostProtocol, serverOptions: AnyCodable.AnyCodable?, transformers: ChimeKit.LSPTransformers = .init(), documentFilter: (ChimeKit.DocumentContext) -> Swift.Bool, executionParamsProvider: @escaping ChimeKit.LSPService.ExecutionParamsProvider)
  #endif
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.LSPService : ChimeKit.ExtensionProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  public func didOpenProject(with context: ChimeKit.ProjectContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func willCloseProject(with context: ChimeKit.ProjectContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func symbolService(for context: ChimeKit.ProjectContext) async throws -> ChimeKit.SymbolQueryService?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func didOpenDocument(with context: ChimeKit.DocumentContext) async throws -> Foundation.URL?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func didChangeDocumentContext(from oldContext: ChimeKit.DocumentContext, to newContext: ChimeKit.DocumentContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func willCloseDocument(with context: ChimeKit.DocumentContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func documentService(for context: ChimeKit.DocumentContext) async throws -> ChimeKit.DocumentService?
  #endif
}
#endif
public enum CompletionFragment : Swift.Codable, Swift.Hashable {
  case text(Swift.String)
  case placeholder(label: Swift.String, content: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.CompletionFragment, b: ChimeKit.CompletionFragment) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct Completion : Swift.Codable, Swift.Hashable {
  public let displayString: Swift.String
  public let range: ChimeKit.TextRange
  public let fragments: [ChimeKit.CompletionFragment]
  public init(displayString: Swift.String, range: ChimeKit.TextRange, fragments: [ChimeKit.CompletionFragment])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.Completion, b: ChimeKit.Completion) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum CompletionTrigger : Swift.Codable, Swift.Hashable {
  case invoked
  case character(Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.CompletionTrigger, b: ChimeKit.CompletionTrigger) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol CompletionService {
  #if compiler(>=5.3) && $AsyncAwait
  func completions(at position: ChimeKit.CombinedTextPosition, trigger: ChimeKit.CompletionTrigger) async throws -> [ChimeKit.Completion]
  #endif
}
extension UniformTypeIdentifiers.UTType {
  public static let goSource: UniformTypeIdentifiers.UTType
  public static let goModFile: UniformTypeIdentifiers.UTType
  public static let goSumFile: UniformTypeIdentifiers.UTType
}
public struct LineRelativeTextPosition : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let line: Swift.Int
  public let offset: Swift.Int
  public init(line: Swift.Int, offset: Swift.Int)
  public init?(location: Swift.Int, lineService: ChimeKit.LineProvider)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.LineRelativeTextPosition, b: ChimeKit.LineRelativeTextPosition) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ChimeKit.LineRelativeTextPosition : Swift.Comparable {
  public static func < (lhs: ChimeKit.LineRelativeTextPosition, rhs: ChimeKit.LineRelativeTextPosition) -> Swift.Bool
}
extension ChimeKit.LineRelativeTextPosition : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc(CodingTextRange) final public class CodingTextRange : ObjectiveC.NSObject {
  final public let value: ChimeKit.TextRange
  public init(_ value: ChimeKit.TextRange)
  @objc deinit
}
extension ChimeKit.CodingTextRange : Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  @objc final public func encode(with coder: Foundation.NSCoder)
  @objc convenience dynamic public init?(coder: Foundation.NSCoder)
}
public typealias CompletionTranslator = (Swift.Int, LanguageServerProtocol.CompletionResponse) -> [ChimeKit.Completion]
public typealias FormattingTranslator = (LanguageServerProtocol.FormattingResult) -> [ChimeKit.TextChange]
public typealias TextEditTranslator = (LanguageServerProtocol.TextEdit) -> ChimeKit.TextChange
public typealias TextEditsTranslator = ([LanguageServerProtocol.TextEdit]) -> [ChimeKit.TextChange]
public typealias OrganizeImportsTransformer = (LanguageServerProtocol.DocumentUri, LanguageServerProtocol.CodeActionResponse) -> [ChimeKit.TextChange]
public typealias DiagnosticTransformer = (LanguageServerProtocol.Diagnostic) -> ChimeKit.Diagnostic
public typealias HoverTransformer = (ChimeKit.CombinedTextPosition, LanguageServerProtocol.HoverResponse) -> ChimeKit.SemanticDetails?
public typealias DefinitionTransformer = (LanguageServerProtocol.DefinitionResponse) -> [ChimeKit.DefinitionLocation]
public typealias WorkspaceSymbolTransformer = (LanguageServerProtocol.WorkspaceSymbol) -> ChimeKit.Symbol
public typealias SymbolInformationTransformer = (LanguageServerProtocol.SymbolInformation) -> ChimeKit.Symbol
public typealias SemanticTokenTransformer = (LanguageServerProtocol.Token) -> ChimeKit.Token
public struct LSPTransformers {
  public let completionTranslator: ChimeKit.CompletionTranslator
  public let textEditTranslator: ChimeKit.TextEditTranslator
  public let diagnosticTransformer: ChimeKit.DiagnosticTransformer
  public let hoverTransformer: ChimeKit.HoverTransformer
  public let definitionTransformer: ChimeKit.DefinitionTransformer
  public let symbolInformationTransformer: ChimeKit.SymbolInformationTransformer
  public let semanticTokenTransformer: ChimeKit.SemanticTokenTransformer
  public init(completionTranslator: @escaping ChimeKit.CompletionTranslator = LSPTransformers.standardCompletionTranslator, textEditTranslator: @escaping ChimeKit.TextEditTranslator = LSPTransformers.standardTextEditTranslator, diagnosticTransformer: @escaping ChimeKit.DiagnosticTransformer = LSPTransformers.standardDiagnosticTransformer, hoverTransformer: @escaping ChimeKit.HoverTransformer = LSPTransformers.standardHoverTransformer, definitionTransformer: @escaping ChimeKit.DefinitionTransformer = LSPTransformers.standardDefinitionTransformer, symbolInformationTransformer: @escaping ChimeKit.SymbolInformationTransformer = LSPTransformers.standardSymbolInformationTransformer, semanticTokenTransformer: @escaping ChimeKit.SemanticTokenTransformer = LSPTransformers.standardSemanticTokenTransformer)
}
extension ChimeKit.LSPTransformers {
  public var textEditsTranslator: ChimeKit.TextEditsTranslator {
    get
  }
  public var formattingTranslator: ChimeKit.FormattingTranslator {
    get
  }
  public var organizeImportsTransformer: ChimeKit.OrganizeImportsTransformer {
    get
  }
  public var workspaceSymbolResponseTransformer: (LanguageServerProtocol.WorkspaceSymbolResponse) -> [ChimeKit.Symbol] {
    get
  }
}
extension ChimeKit.LSPTransformers {
  public static let standardCompletionTranslator: (_ location: Swift.Int, _ response: LanguageServerProtocol.CompletionResponse) -> [ChimeKit.Completion]
}
extension ChimeKit.LSPTransformers {
  public static let standardTextEditTranslator: (_ edit: LanguageServerProtocol.TextEdit) -> ChimeKit.TextChange
}
extension ChimeKit.LSPTransformers {
  public static let standardDiagnosticTransformer: (_ diagnostic: LanguageServerProtocol.Diagnostic) -> ChimeKit.Diagnostic
}
extension ChimeKit.LSPTransformers {
  public static let standardHoverTransformer: (_ position: ChimeKit.CombinedTextPosition, _ response: LanguageServerProtocol.HoverResponse) -> ChimeKit.SemanticDetails?
}
extension ChimeKit.LSPTransformers {
  public static let standardDefinitionTransformer: (_ response: LanguageServerProtocol.DefinitionResponse) -> [ChimeKit.DefinitionLocation]
}
extension ChimeKit.LSPTransformers {
  public static let standardSymbolInformationTransformer: (_ info: LanguageServerProtocol.SymbolInformation) -> ChimeKit.Symbol
}
extension ChimeKit.LSPTransformers {
  public static let standardSemanticTokenTransformer: (_ token: LanguageServerProtocol.Token) -> ChimeKit.Token
}
public struct Line {
  public let index: Swift.Int
  public let range: Foundation.NSRange
  public let whitespaceOnly: Swift.Bool
  public init(index: Swift.Int, range: Foundation.NSRange, whitespaceOnly: Swift.Bool = false)
  public var rangeNotIncludingNewline: Foundation.NSRange {
    get
  }
}
extension ChimeKit.Line {
  public var location: Swift.Int {
    get
  }
  public var length: Swift.Int {
    get
  }
  public var max: Swift.Int {
    get
  }
}
extension ChimeKit.Line : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.Line, b: ChimeKit.Line) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension ChimeKit.Line {
  public func rangeFromBeginning(to endLimit: Swift.Int) -> Foundation.NSRange?
  public func rangeToEnd(from startLimit: Swift.Int) -> Foundation.NSRange?
}
extension Swift.Set where Element == ChimeKit.Line {
  public var lineIndexSet: Swift.Set<Swift.Int> {
    get
  }
  public func containsLineWithIndices(_ indices: [Swift.Int]) -> Swift.Bool
  public func containsLineImmediatelyFollowing(lines: [ChimeKit.Line]) -> Swift.Bool
  public func containsLineImmediatelyPreceeding(lines: [ChimeKit.Line]) -> Swift.Bool
  public func adjacentLines(for lines: [ChimeKit.Line]) -> (Swift.Bool, Swift.Bool)
}
public struct Diagnostic : Swift.Hashable, Swift.Codable, Swift.Sendable {
  public enum Kind : Swift.Hashable, Swift.Codable, Swift.Sendable {
    case hint
    case information
    case warning
    case error
    public static func == (a: ChimeKit.Diagnostic.Kind, b: ChimeKit.Diagnostic.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Relation : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public let message: Swift.String
    public let url: Foundation.URL
    public let range: ChimeKit.TextRange
    public init(message: Swift.String, url: Foundation.URL, range: ChimeKit.TextRange)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: ChimeKit.Diagnostic.Relation, b: ChimeKit.Diagnostic.Relation) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public enum Qualifier : Swift.Hashable, Swift.Codable, Swift.Sendable {
    case deprecated
    case unnecessary
    public static func == (a: ChimeKit.Diagnostic.Qualifier, b: ChimeKit.Diagnostic.Qualifier) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public let range: ChimeKit.TextRange
  public let message: Swift.String
  public let kind: ChimeKit.Diagnostic.Kind
  public let relationships: [ChimeKit.Diagnostic.Relation]
  public let qualifiers: Swift.Set<ChimeKit.Diagnostic.Qualifier>
  public init(range: ChimeKit.TextRange, message: Swift.String, kind: ChimeKit.Diagnostic.Kind, relationships: [ChimeKit.Diagnostic.Relation], qualifiers: Swift.Set<ChimeKit.Diagnostic.Qualifier>)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.Diagnostic, b: ChimeKit.Diagnostic) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public typealias DiagnosticsHandler = ([ChimeKit.Diagnostic]) -> Swift.Void
public protocol DiagnosticsService {
  func setDiagnosticHandler(_ block: ChimeKit.DiagnosticsHandler?)
}
final public class ExportedSceneHost<Host> where Host : ChimeKit.ExtensionSceneHostProtocol {
  public init(_ host: Host)
  @objc deinit
}
public protocol ExtensionSceneProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  func setActiveContext(project: ChimeKit.ProjectContext?, document: ChimeKit.DocumentContext) async throws
  #endif
}
public protocol ExtensionSceneHostProtocol {
}
#if compiler(>=5.3) && $Actors
@_hasMissingDesignatedInitializers public actor ProjectServiceXPCBridge {
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.ProjectServiceXPCBridge : ChimeKit.SymbolQueryService {
  #if compiler(>=5.3) && $AsyncAwait
  public func symbols(matching query: Swift.String) async throws -> [ChimeKit.Symbol]
  #endif
}
#endif
public struct LineParser {
  public init()
  public func parseLines(in string: Swift.String, indexOffset: Swift.Int, locationOffset: Swift.Int, includeLastLine: Swift.Bool) -> [ChimeKit.Line]
}
@objc(CodingCombinedTextPosition) final public class CodingCombinedTextPosition : ObjectiveC.NSObject {
  final public let value: ChimeKit.CombinedTextPosition
  public init(_ value: ChimeKit.CombinedTextPosition)
  @objc deinit
}
extension ChimeKit.CodingCombinedTextPosition : Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  @objc final public func encode(with coder: Foundation.NSCoder)
  @objc convenience dynamic public init?(coder: Foundation.NSCoder)
}
@_hasMissingDesignatedInitializers final public class XPCExtensionBridge<Extension> where Extension : ChimeKit.ExtensionProtocol {
  @objc deinit
}
public enum ChimeExtensionSceneName : Swift.String, Swift.CaseIterable, Swift.Hashable, Swift.Codable, Swift.Sendable {
  case sidebar
  case documentSynced
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ChimeKit.ChimeExtensionSceneName]
  public typealias RawValue = Swift.String
  public static var allCases: [ChimeKit.ChimeExtensionSceneName] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@available(macOS 13.0, *)
public protocol ChimeExtensionScene : ExtensionKit.AppExtensionScene {
}
@available(macOS 13.0, *)
public struct SidebarScene<Content> : ChimeKit.ChimeExtensionScene where Content : SwiftUI.View {
  public init(content: @escaping () -> Content)
  public var body: some ExtensionKit.AppExtensionScene {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s8ChimeKit12SidebarSceneV4bodyQrvp", 0) __<Content>
}
@available(macOS 13.0, *)
public struct DocumentSyncedScene<Content> : ChimeKit.ChimeExtensionScene where Content : SwiftUI.View {
  public init(content: @escaping () -> Content)
  public var body: some ExtensionKit.AppExtensionScene {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s8ChimeKit19DocumentSyncedSceneV4bodyQrvp", 0) __<Content>
}
@_hasMissingDesignatedInitializers public class RemoteLanguageServer {
  final public let wrappedServer: LanguageServerProtocol.JSONRPCLanguageServer
  public var terminationHandler: (() -> Swift.Void)?
  @objc deinit
}
extension ChimeKit.RemoteLanguageServer : LanguageServerProtocol.Server {
  public var requestHandler: ChimeKit.RemoteLanguageServer.RequestHandler? {
    get
    set
  }
  public var notificationHandler: ChimeKit.RemoteLanguageServer.NotificationHandler? {
    get
    set
  }
  public func sendNotification(_ notif: LanguageServerProtocol.ClientNotification, completionHandler: @escaping (LanguageServerProtocol.ServerError?) -> Swift.Void)
  public func sendRequest<Response>(_ request: LanguageServerProtocol.ClientRequest, completionHandler: @escaping (LanguageServerProtocol.ServerResult<Response>) -> Swift.Void) where Response : Swift.Decodable, Response : Swift.Encodable
}
@_hasMissingDesignatedInitializers final public class ProcessService {
  #if compiler(>=5.3) && $EffectfulProp
  public static var userEnvironment: [Swift.String : Swift.String] {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public static func readOutput(with parameters: Foundation.Process.ExecutionParameters) async throws -> Foundation.Data
  #endif
  @objc deinit
}
@objc(CodingProjectContext) final public class CodingProjectContext : ObjectiveC.NSObject {
  final public let value: ChimeKit.ProjectContext
  public init(_ value: ChimeKit.ProjectContext)
  @objc deinit
}
extension ChimeKit.CodingProjectContext : Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  @objc final public func encode(with coder: Foundation.NSCoder)
  @objc convenience dynamic public init?(coder: Foundation.NSCoder)
}
public struct CombinedTextRange : Swift.Codable, Swift.Hashable, @unchecked Swift.Sendable {
  public let version: Swift.Int
  public let range: Foundation.NSRange
  public let lineRelativeRange: ChimeKit.LineRelativeTextRange
  public let limit: Swift.Int
  public init(version: Swift.Int, range: Foundation.NSRange, lineRelativeRange: ChimeKit.LineRelativeTextRange, limit: Swift.Int)
  public init?(range: Foundation.NSRange, length: Swift.Int, version: Swift.Int, lineService: ChimeKit.LineProvider)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.CombinedTextRange, b: ChimeKit.CombinedTextRange) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
@objc(CodingDiagnostic) final public class CodingDiagnostic : ObjectiveC.NSObject {
  final public let value: ChimeKit.Diagnostic
  public init(_ value: ChimeKit.Diagnostic)
  @objc deinit
}
extension ChimeKit.CodingDiagnostic : Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  @objc final public func encode(with coder: Foundation.NSCoder)
  @objc convenience dynamic public init?(coder: Foundation.NSCoder)
}
@objc(CodingTextChange) final public class CodingTextChange : ObjectiveC.NSObject {
  final public let value: ChimeKit.TextChange
  public init(_ value: ChimeKit.TextChange)
  @objc deinit
}
extension ChimeKit.CodingTextChange : Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  @objc final public func encode(with coder: Foundation.NSCoder)
  @objc convenience dynamic public init?(coder: Foundation.NSCoder)
}
public struct DefinitionLocation : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let url: Foundation.URL
  public let highlightRange: ChimeKit.TextRange
  public let selectionRange: ChimeKit.TextRange
  public init(url: Foundation.URL, highlightRange: ChimeKit.TextRange, selectionRange: ChimeKit.TextRange)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.DefinitionLocation, b: ChimeKit.DefinitionLocation) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol DefinitionService {
  #if compiler(>=5.3) && $AsyncAwait
  func definitions(at position: ChimeKit.CombinedTextPosition) async throws -> [ChimeKit.DefinitionLocation]
  #endif
}
public typealias LineRelativeTextRange = Swift.Range<ChimeKit.LineRelativeTextPosition>
extension Swift.Range where Bound == ChimeKit.LineRelativeTextPosition {
  public init?(range: Foundation.NSRange, lineService: ChimeKit.LineProvider)
}
public struct ServiceConfiguration : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let completionTriggers: Swift.Set<Swift.String>
  public init(completionTriggers: Swift.Set<Swift.String> = Set())
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.ServiceConfiguration, b: ChimeKit.ServiceConfiguration) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ChimeKit.HostProtocol {
  public func export(over connection: Foundation.NSXPCConnection)
}
extension ChimeKit.ExtensionProtocol {
  public func export(over connection: Foundation.NSXPCConnection)
}
extension ChimeKit.ExtensionSceneProtocol {
  public func export(over connection: Foundation.NSXPCConnection)
}
extension ChimeKit.ExtensionSceneHostProtocol {
  public func export(over connection: Foundation.NSXPCConnection)
}
public enum TextRange : Swift.Codable, Swift.Hashable, @unchecked Swift.Sendable {
  case range(Foundation.NSRange)
  case lineRelativeRange(ChimeKit.LineRelativeTextRange)
  public func resolve(with provider: ChimeKit.LineProvider) -> Foundation.NSRange?
  public func combinedRange(with provider: ChimeKit.LineProvider, length: Swift.Int, version: Swift.Int) -> ChimeKit.CombinedTextRange?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.TextRange, b: ChimeKit.TextRange) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
#if compiler(>=5.3) && $Actors
@_hasMissingDesignatedInitializers public actor DocumentServiceXPCBridge {
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.DocumentServiceXPCBridge : ChimeKit.DocumentService {
  #if compiler(>=5.3) && $AsyncAwait
  public func willApplyChange(_ change: ChimeKit.CombinedTextChange) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func didApplyChange(_ change: ChimeKit.CombinedTextChange) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func willSave() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func didSave() async throws
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var completionService: ChimeKit.CompletionService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var formattingService: ChimeKit.FormattingService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var semanticDetailsService: ChimeKit.SemanticDetailsService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var defintionService: ChimeKit.DefinitionService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var tokenService: ChimeKit.TokenService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var symbolService: ChimeKit.SymbolQueryService? {
    get async throws
  }
  #endif
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.DocumentServiceXPCBridge : ChimeKit.CompletionService {
  #if compiler(>=5.3) && $AsyncAwait
  public func completions(at position: ChimeKit.CombinedTextPosition, trigger: ChimeKit.CompletionTrigger) async throws -> [ChimeKit.Completion]
  #endif
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.DocumentServiceXPCBridge : ChimeKit.FormattingService {
  #if compiler(>=5.3) && $AsyncAwait
  public func formatting(for ranges: [ChimeKit.CombinedTextRange]) async throws -> [ChimeKit.TextChange]
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func organizeImports() async throws -> [ChimeKit.TextChange]
  #endif
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.DocumentServiceXPCBridge : ChimeKit.SemanticDetailsService {
  #if compiler(>=5.3) && $AsyncAwait
  public func semanticDetails(at position: ChimeKit.CombinedTextPosition) async throws -> ChimeKit.SemanticDetails?
  #endif
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.DocumentServiceXPCBridge : ChimeKit.DefinitionService {
  #if compiler(>=5.3) && $AsyncAwait
  public func definitions(at position: ChimeKit.CombinedTextPosition) async throws -> [ChimeKit.DefinitionLocation]
  #endif
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.DocumentServiceXPCBridge : ChimeKit.TokenService {
  #if compiler(>=5.3) && $AsyncAwait
  public func tokens(in range: ChimeKit.CombinedTextRange) async throws -> [ChimeKit.Token]
  #endif
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.DocumentServiceXPCBridge : ChimeKit.SymbolQueryService {
  #if compiler(>=5.3) && $AsyncAwait
  public func symbols(matching query: Swift.String) async throws -> [ChimeKit.Symbol]
  #endif
}
#endif
public enum ServiceProviderError : Foundation.LocalizedError {
  case invalidURL
  case unableToComputeSourceLocation
  case unableToTransformValue
  case unableToTransformRange
  case noValue
  case staleDocumentState
  case unsupported
  case serviceUnavailable
  case stateInvalid
  case invalidData(Swift.String)
  case serviceFailure(Swift.Error)
}
public typealias ServiceProviderResult<T> = Swift.Result<T, ChimeKit.ServiceProviderError>
final public class RemoteScene {
  public init(connection: Foundation.NSXPCConnection)
  @objc deinit
}
extension ChimeKit.RemoteScene : ChimeKit.ExtensionSceneProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  final public func setActiveContext(project: ChimeKit.ProjectContext?, document: ChimeKit.DocumentContext) async throws
  #endif
}
public protocol DocumentService {
  #if compiler(>=5.3) && $AsyncAwait
  func willApplyChange(_ change: ChimeKit.CombinedTextChange) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func didApplyChange(_ change: ChimeKit.CombinedTextChange) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func willSave() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func didSave() async throws
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  var configuration: ChimeKit.ServiceConfiguration { get async throws }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  var completionService: ChimeKit.CompletionService? { get async throws }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  var formattingService: ChimeKit.FormattingService? { get async throws }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  var semanticDetailsService: ChimeKit.SemanticDetailsService? { get async throws }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  var defintionService: ChimeKit.DefinitionService? { get async throws }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  var tokenService: ChimeKit.TokenService? { get async throws }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  var symbolService: ChimeKit.SymbolQueryService? { get async throws }
  #endif
}
extension ChimeKit.DocumentService {
  #if compiler(>=5.3) && $AsyncAwait
  public func willApplyChange(_ change: ChimeKit.CombinedTextChange) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func didApplyChange(_ change: ChimeKit.CombinedTextChange) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func willSave() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func didSave() async throws
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var completionService: ChimeKit.CompletionService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var formattingService: ChimeKit.FormattingService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var semanticDetailsService: ChimeKit.SemanticDetailsService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var defintionService: ChimeKit.DefinitionService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var tokenService: ChimeKit.TokenService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var symbolService: ChimeKit.SymbolQueryService? {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var configuration: ChimeKit.ServiceConfiguration {
    get async throws
  }
  #endif
}
public protocol ExtensionProtocol : AnyObject {
  #if compiler(>=5.3) && $AsyncAwait
  func didOpenProject(with context: ChimeKit.ProjectContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func willCloseProject(with context: ChimeKit.ProjectContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func didOpenDocument(with context: ChimeKit.DocumentContext) async throws -> Foundation.URL?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func didChangeDocumentContext(from oldContext: ChimeKit.DocumentContext, to newContext: ChimeKit.DocumentContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func willCloseDocument(with context: ChimeKit.DocumentContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func documentService(for context: ChimeKit.DocumentContext) async throws -> ChimeKit.DocumentService?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func symbolService(for context: ChimeKit.ProjectContext) async throws -> ChimeKit.SymbolQueryService?
  #endif
}
extension ChimeKit.ExtensionProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  public func didOpenProject(with context: ChimeKit.ProjectContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func willCloseProject(with context: ChimeKit.ProjectContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func didOpenDocument(with context: ChimeKit.DocumentContext) async throws -> Foundation.URL?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func didChangeDocumentContext(from oldContext: ChimeKit.DocumentContext, to newContext: ChimeKit.DocumentContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func willCloseDocument(with context: ChimeKit.DocumentContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func documentService(for context: ChimeKit.DocumentContext) async throws -> ChimeKit.DocumentService?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func symbolService(for context: ChimeKit.ProjectContext) async throws -> ChimeKit.SymbolQueryService?
  #endif
}
public protocol LineProvider {
  var lineCount: Swift.Int { get }
  var lineCountUsedSoFar: Swift.Int { get }
  func findLine(containing location: Swift.Int) -> ChimeKit.Line?
  func findLines(for range: Foundation.NSRange) -> [ChimeKit.Line]?
  func lineAtIndex(_ index: Swift.Int) -> ChimeKit.Line?
}
extension ChimeKit.LineProvider {
  public func findLines(for ranges: [Foundation.NSRange]) -> [ChimeKit.Line]?
  public var lastLineUsedSoFar: ChimeKit.Line? {
    get
  }
}
extension ChimeKit.LineProvider {
  public func computeLineRelativePosition(at location: Swift.Int) -> ChimeKit.LineRelativeTextPosition?
}
extension ChimeKit.LineProvider {
  public func computeAbsoluteLocation(of position: ChimeKit.LineRelativeTextPosition, clampOutOfBounds: Swift.Bool = false) -> Swift.Int?
}
final public class ExportedScene<Scene> where Scene : ChimeKit.ExtensionSceneProtocol {
  public init(_ scene: Scene)
  @objc deinit
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor final public class DocumentModel : Combine.ObservableObject {
  @Combine.Published @_projectedValueProperty($documentContext) @_Concurrency.MainActor final public var documentContext: ChimeKit.DocumentContext {
    get
  }
  @_Concurrency.MainActor final public var $documentContext: Combine.Published<ChimeKit.DocumentContext>.Publisher {
    get
  }
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor final public func getLine() async -> Foundation.NSRect
  #endif
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
extension ChimeKit.DocumentModel : ChimeKit.ExtensionSceneProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor final public func setActiveContext(project: ChimeKit.ProjectContext?, document: ChimeKit.DocumentContext) async throws
  #endif
}
public struct DocumentContextKey : SwiftUI.EnvironmentKey {
  public static var defaultValue: ChimeKit.DocumentContext
  public typealias Value = ChimeKit.DocumentContext
}
public struct ProjectContextKey : SwiftUI.EnvironmentKey {
  public static var defaultValue: ChimeKit.ProjectContext?
  public typealias Value = ChimeKit.ProjectContext?
}
extension SwiftUI.EnvironmentValues {
  public var documentContext: ChimeKit.DocumentContext {
    get
    set
  }
  public var projectContext: ChimeKit.ProjectContext? {
    get
    set
  }
}
@available(macOS 13.0, *)
@_Concurrency.MainActor(unsafe) public struct SceneContextView<Content> : SwiftUI.View where Content : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public init(content: @escaping () -> Content)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s8ChimeKit16SceneContextViewV4bodyQrvp", 0) __<Content>
}
public enum TextTarget : Swift.Codable, Swift.Hashable, Swift.Sendable {
  case all
  case set(Foundation.IndexSet)
  case range(ChimeKit.TextRange)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.TextTarget, b: ChimeKit.TextTarget) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct Token : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let name: Swift.String
  public let textRange: ChimeKit.TextRange
  public init(name: Swift.String, textRange: ChimeKit.TextRange)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.Token, b: ChimeKit.Token) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol TokenService {
  #if compiler(>=5.3) && $AsyncAwait
  func tokens(in range: ChimeKit.CombinedTextRange) async throws -> [ChimeKit.Token]
  #endif
}
#if compiler(>=5.3) && $Actors
public actor XPCProcessClientBridge {
  public typealias ProcessEventSubject = Combine.PassthroughSubject<Foundation.Process.Event, Swift.Error>
  public typealias ProcessEventPublisher = Combine.Publisher<Foundation.Process.Event, Swift.Error>
  public init()
  public func processEventPublisher(for identifier: Foundation.UUID) -> some Combine.Publisher
  
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
#endif
#if compiler(>=5.3) && $Actors
extension ChimeKit.XPCProcessClientBridge : ChimeKit.ProcessClientXPCProtocol {
  @objc nonisolated public func launchedProcess(with identifier: Foundation.UUID, stdoutData: Foundation.Data)
  @objc nonisolated public func launchedProcess(with identifier: Foundation.UUID, stderrData: Foundation.Data)
  @objc nonisolated public func launchedProcess(with identifier: Foundation.UUID, terminated: Swift.Int)
}
#endif
public struct CombinedTextContent : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let string: Swift.String
  public let range: ChimeKit.CombinedTextRange
  public init(string: Swift.String, range: ChimeKit.CombinedTextRange)
  public var stringLength: Swift.Int {
    get
  }
  public var version: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.CombinedTextContent, b: ChimeKit.CombinedTextContent) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct CombinedTextChange : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let string: Swift.String
  public let textRange: ChimeKit.CombinedTextRange
  public init(string: Swift.String, textRange: ChimeKit.CombinedTextRange)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.CombinedTextChange, b: ChimeKit.CombinedTextChange) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ChimeKit.CombinedTextChange {
  public var delta: Swift.Int {
    get
  }
  public var postApplyLimit: Swift.Int {
    get
  }
}
public struct TextChange : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let string: Swift.String
  public let textRange: ChimeKit.TextRange
  public init(string: Swift.String, textRange: ChimeKit.TextRange)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.TextChange, b: ChimeKit.TextChange) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public typealias DocumentIdentity = Foundation.UUID
public typealias DocumentContentIdentity = Foundation.UUID
public struct DocumentContext : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let id: ChimeKit.DocumentIdentity
  public let contentId: ChimeKit.DocumentContentIdentity
  public let url: Foundation.URL?
  public let uti: UniformTypeIdentifiers.UTType
  public let configuration: ChimeKit.DocumentConfiguration
  public let projectContext: ChimeKit.ProjectContext?
  public init(id: ChimeKit.DocumentIdentity, contentId: ChimeKit.DocumentContentIdentity, url: Foundation.URL?, uti: UniformTypeIdentifiers.UTType, configuration: ChimeKit.DocumentConfiguration, projectContext: ChimeKit.ProjectContext?)
  public init()
  public var enclosingProjectURL: Foundation.URL? {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.DocumentContext, b: ChimeKit.DocumentContext) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ChimeKit.DocumentContext : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc public protocol ProcessServerXPCProtocol {
  @objc func launchProcess(at url: Foundation.URL, arguments: [Swift.String], environment: [Swift.String : Swift.String]?, currentDirectoryURL: Foundation.URL?, completionHandler: @escaping (Foundation.UUID?, Swift.Error?) -> Swift.Void)
  @objc func terminateProcess(with identifier: Foundation.UUID, completionHandler: @escaping (Swift.Error?) -> Swift.Void)
  @objc func writeDataToStdin(_ data: Foundation.Data, for identifier: Foundation.UUID, completionHandler: @escaping (Swift.Error?) -> Swift.Void)
  @objc func captureUserEnvironment(completionHandler: @escaping ([Swift.String : Swift.String]?, Swift.Error?) -> Swift.Void)
}
@objc public protocol ProcessClientXPCProtocol {
  @objc func launchedProcess(with identifier: Foundation.UUID, stdoutData: Foundation.Data)
  @objc func launchedProcess(with identifier: Foundation.UUID, stderrData: Foundation.Data)
  @objc func launchedProcess(with identifier: Foundation.UUID, terminated: Swift.Int)
}
extension Foundation.NSXPCConnection {
  public static var processService: Foundation.NSXPCConnection {
    get
  }
}
public struct SemanticDetails {
  public let textRange: ChimeKit.TextRange
  public let synopsis: Swift.String?
  public let declaration: Swift.String?
  public let documentation: Swift.String?
  public let containsMarkdown: Swift.Bool
  public init(textRange: ChimeKit.TextRange, synopsis: Swift.String? = nil, declaration: Swift.String? = nil, documentation: Swift.String? = nil, containsMarkdown: Swift.Bool = false)
  public var onlyDocumentation: Swift.Bool {
    get
  }
}
extension ChimeKit.SemanticDetails : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.SemanticDetails, b: ChimeKit.SemanticDetails) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension ChimeKit.SemanticDetails : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol SemanticDetailsService {
  #if compiler(>=5.3) && $AsyncAwait
  func semanticDetails(at position: ChimeKit.CombinedTextPosition) async throws -> ChimeKit.SemanticDetails?
  #endif
}
public struct DocumentConfiguration : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let indentIsSoft: Swift.Bool
  public let indentSize: Swift.Int
  public let tabWidth: Swift.Int
  public init(indentIsSoft: Swift.Bool = false, indentSize: Swift.Int, tabWidth: Swift.Int)
  public init(indentIsSoft: Swift.Bool = false, indentSize: Swift.Int = 4)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.DocumentConfiguration, b: ChimeKit.DocumentConfiguration) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ChimeKit.DocumentConfiguration {
  public var indentationUnit: Swift.String {
    get
  }
}
public struct CombinedTextPosition : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let location: Swift.Int
  public let relativePosition: ChimeKit.LineRelativeTextPosition
  public init(location: Swift.Int, relativePosition: ChimeKit.LineRelativeTextPosition)
  public init?(location: Swift.Int, lineService: ChimeKit.LineProvider)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.CombinedTextPosition, b: ChimeKit.CombinedTextPosition) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ChimeKit.CombinedTextPosition : Swift.Comparable {
  public static func < (lhs: ChimeKit.CombinedTextPosition, rhs: ChimeKit.CombinedTextPosition) -> Swift.Bool
}
public protocol FormattingService {
  #if compiler(>=5.3) && $AsyncAwait
  func formatting(for ranges: [ChimeKit.CombinedTextRange]) async throws -> [ChimeKit.TextChange]
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func organizeImports() async throws -> [ChimeKit.TextChange]
  #endif
}
public enum UnrestrictedProcessError : Swift.Error {
  case alreadyLaunched(Foundation.UUID)
  case notRunning
  case connectionInvalid
}
extension Foundation.Process {
  public enum Event {
    case stdout(Foundation.Data)
    case stderr(Foundation.Data)
    case terminated(Foundation.Process.TerminationReason)
  }
}
#if compiler(>=5.3) && $Actors
public actor UnrestrictedProcess {
  public init(parameters: Foundation.Process.ExecutionParameters) throws
  #if compiler(>=5.3) && $AsyncAwait
  public func launch() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func terminate() async throws
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var processEventPublisher: some Combine.Publisher {
    get async throws
  }
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func write(_ data: Foundation.Data) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func runAndReadStdout() async throws -> Foundation.Data
  #endif
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
#endif
final public class ExtensionXPCBridge {
  public init(connection: Foundation.NSXPCConnection) throws
  @objc deinit
}
extension ChimeKit.ExtensionXPCBridge : ChimeKit.ExtensionProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  final public func didOpenProject(with context: ChimeKit.ProjectContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func willCloseProject(with context: ChimeKit.ProjectContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func didOpenDocument(with context: ChimeKit.DocumentContext) async throws -> Foundation.URL?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func didChangeDocumentContext(from oldContext: ChimeKit.DocumentContext, to newContext: ChimeKit.DocumentContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func willCloseDocument(with context: ChimeKit.DocumentContext) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func documentService(for context: ChimeKit.DocumentContext) async throws -> ChimeKit.DocumentService?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func symbolService(for context: ChimeKit.ProjectContext) async throws -> ChimeKit.SymbolQueryService?
  #endif
}
extension _Concurrency.CheckedContinuation where T : Swift.Decodable, E == Swift.Error {
  public var resumingHandler: (Foundation.Data?, Swift.Error?) -> Swift.Void {
    get
  }
}
public typealias CodingCombinedTextChange = ChimeKit.CodingCombinedTextContent
public enum XPCBridgeError : Swift.Error {
  case unsupported
  case invalidInterface
  case missingExpectedValue(Swift.String)
  case parameterEncodingError(Swift.Error)
}
public struct Symbol : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public enum Kind : Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.CaseIterable {
    case function
    case method
    case module
    public static func == (a: ChimeKit.Symbol.Kind, b: ChimeKit.Symbol.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [ChimeKit.Symbol.Kind]
    public static var allCases: [ChimeKit.Symbol.Kind] {
      get
    }
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public let name: Swift.String
  public let containerName: Swift.String?
  public let kind: ChimeKit.Symbol.Kind
  public let url: Foundation.URL
  public let range: ChimeKit.TextRange?
  public init(name: Swift.String, containerName: Swift.String? = nil, kind: ChimeKit.Symbol.Kind, url: Foundation.URL, range: ChimeKit.TextRange? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.Symbol, b: ChimeKit.Symbol) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol SymbolQueryService {
  #if compiler(>=5.3) && $AsyncAwait
  func symbols(matching query: Swift.String) async throws -> [ChimeKit.Symbol]
  #endif
}
final public class HostXPCBridge {
  public init(_ connection: Foundation.NSXPCConnection) throws
  @objc deinit
}
extension ChimeKit.HostXPCBridge : ChimeKit.HostProtocol {
  #if compiler(>=5.3) && $AsyncAwait
  final public func textContent(for documentId: ChimeKit.DocumentIdentity) async throws -> (Swift.String, Swift.Int)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func textContent(for documentId: ChimeKit.DocumentIdentity, in range: ChimeKit.TextRange) async throws -> ChimeKit.CombinedTextContent
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func textBounds(for documentId: ChimeKit.DocumentIdentity, in ranges: [ChimeKit.TextRange], version: Swift.Int) async throws -> [Foundation.NSRect]
  #endif
  final public func publishDiagnostics(_ diagnostics: [ChimeKit.Diagnostic], for documentURL: Foundation.URL, version: Swift.Int?)
  final public func invalidateTokens(for documentId: Foundation.UUID, in target: ChimeKit.TextTarget)
  final public func documentServiceConfigurationChanged(for documentId: ChimeKit.DocumentIdentity, to configuration: ChimeKit.ServiceConfiguration)
}
public typealias ProjectIdentity = Foundation.UUID
public struct ProjectContext : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let id: ChimeKit.ProjectIdentity
  public let url: Foundation.URL
  public init(id: ChimeKit.ProjectIdentity = UUID(), url: Foundation.URL)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ChimeKit.ProjectContext, b: ChimeKit.ProjectContext) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public protocol ProjectContextual {
  #if compiler(>=5.3) && $EffectfulProp
  var projectContext: ChimeKit.ProjectContext { get async }
  #endif
}
@_hasMissingDesignatedInitializers final public class XPCHostBridge<Host> where Host : ChimeKit.HostProtocol {
  @objc deinit
}
@objc(CodingCombinedTextRange) final public class CodingCombinedTextRange : ObjectiveC.NSObject {
  final public let value: ChimeKit.CombinedTextRange
  public init(_ value: ChimeKit.CombinedTextRange)
  @objc deinit
}
extension ChimeKit.CodingCombinedTextRange : Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  @objc final public func encode(with coder: Foundation.NSCoder)
  @objc convenience dynamic public init?(coder: Foundation.NSCoder)
}
extension ChimeKit.ChimeExtensionPoint : Swift.RawRepresentable {}
extension ChimeKit.ChimeExtensionSceneName : Swift.RawRepresentable {}
extension ChimeKit.DocumentModel : Swift.Sendable {}
